#!/usr/bin/env python3
"""
Archon-Generated Setup Script for BlueBirdHub
Auto-generated by Archon AI Agent System

This script implements the Priority 1 recommendations from Archon's analysis.
"""

import os
import sys
import subprocess
from pathlib import Path

class BlueBirdHubSetup:
    def __init__(self):
        self.project_root = Path(__file__).parent.parent
        self.backend_dir = self.project_root / "src" / "backend"
        
    def create_directory_structure(self):
        """Create the recommended directory structure from Archon analysis"""
        directories = [
            "src/backend/core/database",
            "src/backend/core/auth", 
            "src/backend/core/ai_services",
            "src/backend/core/security",
            "src/backend/migrations",
            "scripts/archon_generated"
        ]
        
        for directory in directories:
            (self.project_root / directory).mkdir(parents=True, exist_ok=True)
            print(f"✅ Created directory: {directory}")
    
    def generate_database_manager(self):
        """Generate the database abstraction layer recommended by Archon"""
        db_manager_code = '''"""
Database Manager - Generated by Archon AI System
Implements the database abstraction layer from Archon's recommendations
"""

from __future__ import annotations
import os
from typing import Optional

from sqlalchemy import create_engine, event
from sqlalchemy.orm import sessionmaker, scoped_session, DeclarativeBase
from sqlalchemy.pool import QueuePool
from sqlalchemy_utils import database_exists, create_database

class Base(DeclarativeBase):
    """Base class for all database models"""
    pass

class DatabaseManager:
    _instance: Optional[DatabaseManager] = None
    
    def __init__(self, connection_string: str = None):
        self.connection_string = connection_string or self._get_connection_string()
        
        # Ensure database exists
        if not database_exists(self.connection_string):
            create_database(self.connection_string)
        
        # Create engine with connection pooling
        self.engine = create_engine(
            self.connection_string,
            poolclass=QueuePool,
            pool_size=10,
            max_overflow=20,
            pool_timeout=30,
            pool_recycle=1800  # Recycle connections every 30 minutes
        )
        
        # Create session factory
        self.SessionLocal = scoped_session(
            sessionmaker(
                bind=self.engine, 
                autocommit=False, 
                autoflush=False
            )
        )
    
    @classmethod
    def get_instance(cls, connection_string: str = None) -> DatabaseManager:
        """Singleton pattern for database manager"""
        if not cls._instance:
            cls._instance = DatabaseManager(connection_string)
        return cls._instance
    
    def _get_connection_string(self) -> str:
        """Retrieve database connection string from environment"""
        db_type = os.getenv('DB_TYPE', 'postgresql')
        db_user = os.getenv('DB_USER', 'bluebbird')
        db_pass = os.getenv('DB_PASS', 'secure_password')
        db_host = os.getenv('DB_HOST', 'localhost')
        db_name = os.getenv('DB_NAME', 'bluebbirdhub')
        
        if db_type == 'sqlite':
            return f'sqlite:////{db_name}.db'
        else:
            return f'{db_type}://{db_user}:{db_pass}@{db_host}/{db_name}'
    
    def get_session(self):
        """Provide a database session"""
        session = self.SessionLocal()
        try:
            yield session
        finally:
            session.close()
    
    def init_models(self):
        """Create all database tables"""
        Base.metadata.create_all(bind=self.engine)
'''
        
        db_file = self.project_root / "src/backend/core/database/manager.py"
        with open(db_file, 'w') as f:
            f.write(db_manager_code)
        print(f"✅ Generated database manager: {db_file}")
    
    def generate_auth_system(self):
        """Generate the authentication system recommended by Archon"""
        auth_code = '''"""
Authentication Manager - Generated by Archon AI System
Implements enhanced authentication from Archon's recommendations
"""

from __future__ import annotations
import os
from datetime import datetime, timedelta
from typing import Optional, Dict, Any

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import jwt, JWTError
from passlib.context import CryptContext
from pydantic import BaseModel, EmailStr

class UserSchema(BaseModel):
    id: Optional[int] = None
    username: str
    email: EmailStr
    is_active: bool = True
    is_superuser: bool = False

class UserCreate(BaseModel):
    username: str
    email: EmailStr
    password: str

class AuthManager:
    def __init__(self):
        self.SECRET_KEY = os.getenv('AUTH_SECRET_KEY', 'your-ultra-secure-secret-key')
        self.ALGORITHM = "HS256"
        self.ACCESS_TOKEN_EXPIRE_MINUTES = 30
        
        self.pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
        self.oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        """Verify user password"""
        return self.pwd_context.verify(plain_password, hashed_password)

    def get_password_hash(self, password: str) -> str:
        """Generate password hash"""
        return self.pwd_context.hash(password)

    def create_access_token(self, data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:
        """Create JWT access token"""
        to_encode = data.copy()
        
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=15)
        
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, self.SECRET_KEY, algorithm=self.ALGORITHM)
        
        return encoded_jwt

    def decode_token(self, token: str) -> Dict[str, Any]:
        """Decode and validate JWT token"""
        try:
            payload = jwt.decode(token, self.SECRET_KEY, algorithms=[self.ALGORITHM])
            return payload
        except JWTError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not validate credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )

    def get_current_user(self, token: str = Depends(oauth2_scheme)) -> UserSchema:
        """Retrieve current authenticated user"""
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
        
        try:
            payload = self.decode_token(token)
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
        except JWTError:
            raise credentials_exception
        
        return UserSchema(
            id=payload.get('user_id'),
            username=username,
            email=payload.get('email'),
            is_active=payload.get('is_active', True)
        )

# Singleton instance
auth_manager = AuthManager()
'''
        
        auth_file = self.project_root / "src/backend/core/auth/manager.py"
        with open(auth_file, 'w') as f:
            f.write(auth_code)
        print(f"✅ Generated auth manager: {auth_file}")
    
    def generate_ai_framework(self):
        """Generate the AI service framework recommended by Archon"""
        ai_code = '''"""
AI Service Framework - Generated by Archon AI System
Implements pluggable AI provider system from Archon's recommendations
"""

from __future__ import annotations
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
import asyncio
import logging

class AIServiceProvider(ABC):
    """Abstract base class for AI service providers"""
    
    @abstractmethod
    async def process_document(self, document: bytes) -> Dict[str, Any]:
        """Standard interface for document processing"""
        pass
    
    @abstractmethod
    async def analyze_content(self, content: str) -> Dict[str, Any]:
        """Analyze text content"""
        pass

class OpenAIProvider(AIServiceProvider):
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.client = None  # Initialize OpenAI client
    
    async def process_document(self, document: bytes) -> Dict[str, Any]:
        """Process document using OpenAI"""
        return {"provider": "openai", "status": "processed"}
    
    async def analyze_content(self, content: str) -> Dict[str, Any]:
        """Analyze content using OpenAI"""
        return {"provider": "openai", "analysis": "completed"}

class AnthropicProvider(AIServiceProvider):
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.client = None  # Initialize Anthropic client
    
    async def process_document(self, document: bytes) -> Dict[str, Any]:
        """Process document using Anthropic"""
        return {"provider": "anthropic", "status": "processed"}
    
    async def analyze_content(self, content: str) -> Dict[str, Any]:
        """Analyze content using Anthropic"""
        return {"provider": "anthropic", "analysis": "completed"}

class AIOrchestrator:
    """Orchestrates multiple AI providers with fallback support"""
    
    def __init__(self, providers: List[AIServiceProvider]):
        self.providers = providers
        self.logger = logging.getLogger(__name__)
    
    async def process_with_fallback(self, document: bytes) -> Dict[str, Any]:
        """Process document with fallback to next provider on failure"""
        for i, provider in enumerate(self.providers):
            try:
                result = await provider.process_document(document)
                self.logger.info(f"Successfully processed with provider {i}")
                return result
            except Exception as e:
                self.logger.warning(f"Provider {i} failed: {e}")
                continue
        
        raise ValueError("No AI provider could process the document")
    
    async def analyze_with_fallback(self, content: str) -> Dict[str, Any]:
        """Analyze content with fallback support"""
        for i, provider in enumerate(self.providers):
            try:
                result = await provider.analyze_content(content)
                self.logger.info(f"Successfully analyzed with provider {i}")
                return result
            except Exception as e:
                self.logger.warning(f"Provider {i} failed: {e}")
                continue
        
        raise ValueError("No AI provider could analyze the content")

# Factory function
def create_ai_orchestrator() -> AIOrchestrator:
    """Create AI orchestrator with configured providers"""
    providers = []
    
    # Add providers based on available API keys
    import os
    if os.getenv('OPENAI_API_KEY'):
        providers.append(OpenAIProvider(os.getenv('OPENAI_API_KEY')))
    
    if os.getenv('ANTHROPIC_API_KEY'):
        providers.append(AnthropicProvider(os.getenv('ANTHROPIC_API_KEY')))
    
    if not providers:
        raise ValueError("No AI providers configured. Please set API keys.")
    
    return AIOrchestrator(providers)
'''
        
        ai_file = self.project_root / "src/backend/core/ai_services/framework.py"
        with open(ai_file, 'w') as f:
            f.write(ai_code)
        print(f"✅ Generated AI framework: {ai_file}")
    
    def generate_requirements(self):
        """Generate requirements.txt with Archon's recommended dependencies"""
        requirements = """# Archon-Generated Requirements for BlueBirdHub
# Core Framework
fastapi>=0.104.0
uvicorn[standard]>=0.24.0
pydantic>=2.4.0

# Database
sqlalchemy>=2.0.0
sqlalchemy-utils>=0.41.0
alembic>=1.12.0
psycopg2-binary>=2.9.0

# Authentication
python-jose[cryptography]>=3.3.0
python-multipart>=0.0.6
passlib[bcrypt]>=1.7.4

# AI Integrations
openai>=1.3.0
anthropic>=0.7.0

# Development
pytest>=7.4.0
pytest-asyncio>=0.21.0
black>=23.0.0
ruff>=0.1.0

# Production
gunicorn>=21.2.0
python-dotenv>=1.0.0
"""
        
        req_file = self.project_root / "requirements-archon.txt"
        with open(req_file, 'w') as f:
            f.write(requirements)
        print(f"✅ Generated requirements: {req_file}")
    
    def generate_env_template(self):
        """Generate .env template with Archon's configuration"""
        env_template = """# Archon-Generated Environment Configuration for BlueBirdHub

# Database Configuration
DB_TYPE=postgresql
DB_USER=bluebbird
DB_PASS=secure_password
DB_HOST=localhost
DB_NAME=bluebbirdhub

# Authentication
AUTH_SECRET_KEY=your-ultra-secure-secret-key-change-this

# AI Services
OPENAI_API_KEY=your-openai-api-key
ANTHROPIC_API_KEY=your-anthropic-api-key

# Application Settings
APP_NAME=BlueBirdHub
APP_VERSION=1.0.0
DEBUG=true
"""
        
        env_file = self.project_root / ".env.archon"
        with open(env_file, 'w') as f:
            f.write(env_template)
        print(f"✅ Generated environment template: {env_file}")
    
    def run_setup(self):
        """Execute the complete setup process"""
        print("🚀 Starting Archon-Generated BlueBirdHub Setup...")
        print("=" * 60)
        
        self.create_directory_structure()
        self.generate_database_manager()
        self.generate_auth_system()
        self.generate_ai_framework()
        self.generate_requirements()
        self.generate_env_template()
        
        print("=" * 60)
        print("✅ Archon setup complete!")
        print("\nNext steps:")
        print("1. Install dependencies: pip install -r requirements-archon.txt")
        print("2. Copy .env.archon to .env and update with your values")
        print("3. Run database migrations")
        print("4. Start the application")

if __name__ == "__main__":
    setup = BlueBirdHubSetup()
    setup.run_setup()